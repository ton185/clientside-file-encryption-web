<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Secure File Processor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            padding: 40px;
            width: 100%;
            max-width: 500px;
            backdrop-filter: blur(10px);
        }

        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 10px;
            font-weight: 600;
        }

        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
            font-size: 1rem;
        }

        .form-group {
            margin-bottom: 25px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: #444;
        }

        .password-input {
            width: 100%;
            padding: 15px;
            border: 2px solid #ddd;
            border-radius: 10px;
            font-size: 16px;
            transition: border-color 0.3s ease;
        }

        .password-input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .checkbox-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .checkbox-container input {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }

        .checkbox-container label {
            margin-bottom: 0;
            cursor: pointer;
            font-weight: normal;
            color: #555;
        }

        .file-input-wrapper {
            border: 2px dashed #ddd;
            border-radius: 10px;
            padding: 30px 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            background: #f8f9fa;
        }

        .file-input-wrapper:hover {
            border-color: #667eea;
            background: #eef2ff;
        }

        .file-input-wrapper.drag-over {
            border-color: #667eea;
            background: #eef2ff;
        }

        .file-input-wrapper i {
            font-size: 48px;
            color: #667eea;
            margin-bottom: 15px;
        }

        .file-input-wrapper p {
            color: #666;
            margin-bottom: 10px;
        }

        .file-input-wrapper span {
            color: #667eea;
            font-weight: 500;
        }

        .file-input {
            display: none;
        }

        .submit-btn-container {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .submit-btn {
            flex: 1;
            padding: 15px;
            border: none;
            border-radius: 10px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .encrypt-btn {
            background: linear-gradient(135deg, #4CAF50 0%, #2E7D32 100%);
            color: white;
        }

        .decrypt-btn {
            background: linear-gradient(135deg, #2196F3 0%, #0D47A1 100%);
            color: white;
        }

        .submit-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .file-info {
            margin-top: 10px;
            padding: 10px;
            background: #e8f5e9;
            border-radius: 8px;
            display: none;
        }

        .file-info.show {
            display: block;
        }

        .file-name {
            font-weight: 500;
            color: #2e7d32;
        }

        .file-size {
            color: #666;
            font-size: 0.9em;
        }

        .result-container {
            margin-top: 30px;
            padding: 20px;
            border-radius: 10px;
            background: #f0f8ff;
            border-left: 4px solid #667eea;
            display: none;
        }

        .result-container.show {
            display: block;
        }

        .result-title {
            color: #333;
            margin-bottom: 15px;
            font-weight: 600;
        }

        .result-content {
            color: #444;
            line-height: 1.6;
        }

        .error {
            background: #ffebee;
            border-left-color: #f44336;
        }

        .success {
            background: #e8f5e9;
            border-left-color: #4caf50;
        }

        .loading {
            display: none;
            text-align: center;
            padding: 20px;
        }

        .loading.show {
            display: block;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading-steps {
            margin-top: 20px;
            text-align: left;
        }

        .loading-step {
            padding: 10px;
            margin: 5px 0;
            border-radius: 5px;
            background: #e3f2fd;
            display: none;
        }

        .loading-step.active {
            background: #bbdefb;
            font-weight: 500;
            display: inherit;
        }

        .loading-step.completed {
            background: #c8e6c9;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Secure File Processor</h1>
        <p class="subtitle">Encrypt and Decrypt your files securely</p>

        <form id="secureForm">
            <div class="form-group">
                <label for="password">Password</label>
                <input
                    type="password"
                    id="password"
                    class="password-input"
                    placeholder="Enter your password"
                    required
                >
            </div>

            <div class="form-group">
                <div class="checkbox-container">
                    <input type="checkbox" id="deriveKey" checked>
                    <label for="deriveKey">Derive key from password</label>
                </div>
                <div class="checkbox-container">
                    <input type="checkbox" id="encryptFilename" checked>
                    <label for="encryptFilename">Encrypt Filename</label>
                </div>
                <div class="checkbox-container">
                    <input type="checkbox" id="burnAfterRead">
                    <label for="burnAfterRead">Burn After Read</label>
                </div>
            </div>

            <div class="form-group">
                <label>File Upload</label>
                <div class="file-input-wrapper" id="fileDropZone">
                    <i>üìÅ</i>
                    <p>Drag & drop your file here</p>
                    <p>or</p>
                    <span>Click to browse</span>
                    <input
                        type="file"
                        id="fileInput"
                        class="file-input"
                        accept="*/*"
                    >
                </div>
                <div class="file-info" id="fileInfo">
                    <span class="file-name" id="fileName"></span>
                    <span class="file-size" id="fileSize"></span>
                </div>
            </div>

            <div class="submit-btn-container">
                <button type="button" class="submit-btn encrypt-btn" id="encryptBtn">Encrypt File</button>
                <button type="button" class="submit-btn decrypt-btn" id="decryptBtn">Decrypt File</button>
            </div>
        </form>

        <div class="loading" id="loading">
            <div class="spinner"></div>
            <p>Processing file...</p>
            <div class="loading-steps" id="loadingSteps">
                <div class="loading-step" id="stepinfo"></div>
            </div>
        </div>

        <div class="result-container" id="resultContainer">
            <div class="result-title" id="resultTitle"></div>
            <div class="result-content" id="resultContent"></div>
            <button id="downloadBtn" class="submit-btn encrypt-btn" style="margin-top: 15px; display: none;">
                Download Result File
            </button>
        </div>
    </div>

    <script>
    var nobleCiphers = (() => {
  // ../../esm/utils.js
  function isBytes(a) {
    return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
  }
  function abool(b) {
    if (typeof b !== "boolean")
      throw new Error(`boolean expected, not ${b}`);
  }
  function anumber(n) {
    if (!Number.isSafeInteger(n) || n < 0)
      throw new Error("positive integer expected, got " + n);
  }
  function abytes(b, ...lengths) {
    if (!isBytes(b))
      throw new Error("Uint8Array expected");
    if (lengths.length > 0 && !lengths.includes(b.length))
      throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b.length);
  }
  function aexists(instance, checkFinished = true) {
    if (instance.destroyed)
      throw new Error("Hash instance has been destroyed");
    if (checkFinished && instance.finished)
      throw new Error("Hash#digest() has already been called");
  }
  function aoutput(out, instance) {
    abytes(out);
    const min = instance.outputLen;
    if (out.length < min) {
      throw new Error("digestInto() expects output buffer of length at least " + min);
    }
  }
  function u8(arr) {
    return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
  }
  function u32(arr) {
    return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
  }
  function clean(...arrays) {
    for (let i = 0; i < arrays.length; i++) {
      arrays[i].fill(0);
    }
  }
  function createView(arr) {
    return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
  }
  var isLE = /* @__PURE__ */ (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();
  var hasHexBuiltin = /* @__PURE__ */ (() => (
    // @ts-ignore
    typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function"
  ))();
  var hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
  function bytesToHex(bytes) {
    abytes(bytes);
    if (hasHexBuiltin)
      return bytes.toHex();
    let hex = "";
    for (let i = 0; i < bytes.length; i++) {
      hex += hexes[bytes[i]];
    }
    return hex;
  }
  var asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
  function asciiToBase16(ch) {
    if (ch >= asciis._0 && ch <= asciis._9)
      return ch - asciis._0;
    if (ch >= asciis.A && ch <= asciis.F)
      return ch - (asciis.A - 10);
    if (ch >= asciis.a && ch <= asciis.f)
      return ch - (asciis.a - 10);
    return;
  }
  function hexToBytes(hex) {
    if (typeof hex !== "string")
      throw new Error("hex string expected, got " + typeof hex);
    if (hasHexBuiltin)
      return Uint8Array.fromHex(hex);
    const hl = hex.length;
    const al = hl / 2;
    if (hl % 2)
      throw new Error("hex string expected, got unpadded hex of length " + hl);
    const array = new Uint8Array(al);
    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
      const n1 = asciiToBase16(hex.charCodeAt(hi));
      const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
      if (n1 === void 0 || n2 === void 0) {
        const char = hex[hi] + hex[hi + 1];
        throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
      }
      array[ai] = n1 * 16 + n2;
    }
    return array;
  }
  function utf8ToBytes(str) {
    if (typeof str !== "string")
      throw new Error("string expected");
    return new Uint8Array(new TextEncoder().encode(str));
  }
  function bytesToUtf8(bytes) {
    return new TextDecoder().decode(bytes);
  }
  function toBytes(data) {
    if (typeof data === "string")
      data = utf8ToBytes(data);
    else if (isBytes(data))
      data = copyBytes(data);
    else
      throw new Error("Uint8Array expected, got " + typeof data);
    return data;
  }
  function overlapBytes(a, b) {
    return a.buffer === b.buffer && // best we can do, may fail with an obscure Proxy
    a.byteOffset < b.byteOffset + b.byteLength && // a starts before b end
    b.byteOffset < a.byteOffset + a.byteLength;
  }
  function complexOverlapBytes(input, output) {
    if (overlapBytes(input, output) && input.byteOffset < output.byteOffset)
      throw new Error("complex overlap of input and output is not supported");
  }
  function concatBytes(...arrays) {
    let sum = 0;
    for (let i = 0; i < arrays.length; i++) {
      const a = arrays[i];
      abytes(a);
      sum += a.length;
    }
    const res = new Uint8Array(sum);
    for (let i = 0, pad = 0; i < arrays.length; i++) {
      const a = arrays[i];
      res.set(a, pad);
      pad += a.length;
    }
    return res;
  }
  function checkOpts(defaults, opts) {
    if (opts == null || typeof opts !== "object")
      throw new Error("options must be defined");
    const merged = Object.assign(defaults, opts);
    return merged;
  }
  function equalBytes(a, b) {
    if (a.length !== b.length)
      return false;
    let diff = 0;
    for (let i = 0; i < a.length; i++)
      diff |= a[i] ^ b[i];
    return diff === 0;
  }
  var wrapCipher = /* @__NO_SIDE_EFFECTS__ */ (params, constructor) => {
    function wrappedCipher(key, ...args) {
      abytes(key);
      if (!isLE)
        throw new Error("Non little-endian hardware is not yet supported");
      if (params.nonceLength !== void 0) {
        const nonce = args[0];
        if (!nonce)
          throw new Error("nonce / iv required");
        if (params.varSizeNonce)
          abytes(nonce);
        else
          abytes(nonce, params.nonceLength);
      }
      const tagl = params.tagLength;
      if (tagl && args[1] !== void 0) {
        abytes(args[1]);
      }
      const cipher = constructor(key, ...args);
      const checkOutput = (fnLength, output) => {
        if (output !== void 0) {
          if (fnLength !== 2)
            throw new Error("cipher output not supported");
          abytes(output);
        }
      };
      let called = false;
      const wrCipher = {
        encrypt(data, output) {
          if (called)
            throw new Error("cannot encrypt() twice with same key + nonce");
          called = true;
          abytes(data);
          checkOutput(cipher.encrypt.length, output);
          return cipher.encrypt(data, output);
        },
        decrypt(data, output) {
          abytes(data);
          if (tagl && data.length < tagl)
            throw new Error("invalid ciphertext length: smaller than tagLength=" + tagl);
          checkOutput(cipher.decrypt.length, output);
          return cipher.decrypt(data, output);
        }
      };
      return wrCipher;
    }
    Object.assign(wrappedCipher, params);
    return wrappedCipher;
  };
  function getOutput(expectedLength, out, onlyAligned = true) {
    if (out === void 0)
      return new Uint8Array(expectedLength);
    if (out.length !== expectedLength)
      throw new Error("invalid output length, expected " + expectedLength + ", got: " + out.length);
    if (onlyAligned && !isAligned32(out))
      throw new Error("invalid output, must be aligned");
    return out;
  }
  function setBigUint64(view, byteOffset, value, isLE2) {
    if (typeof view.setBigUint64 === "function")
      return view.setBigUint64(byteOffset, value, isLE2);
    const _32n = BigInt(32);
    const _u32_max = BigInt(4294967295);
    const wh = Number(value >> _32n & _u32_max);
    const wl = Number(value & _u32_max);
    const h = isLE2 ? 4 : 0;
    const l = isLE2 ? 0 : 4;
    view.setUint32(byteOffset + h, wh, isLE2);
    view.setUint32(byteOffset + l, wl, isLE2);
  }
  function u64Lengths(dataLength, aadLength, isLE2) {
    abool(isLE2);
    const num = new Uint8Array(16);
    const view = createView(num);
    setBigUint64(view, 0, BigInt(aadLength), isLE2);
    setBigUint64(view, 8, BigInt(dataLength), isLE2);
    return num;
  }
  function isAligned32(bytes) {
    return bytes.byteOffset % 4 === 0;
  }
  function copyBytes(bytes) {
    return Uint8Array.from(bytes);
  }

  // ../../esm/_arx.js
  var _utf8ToBytes = (str) => Uint8Array.from(str.split("").map((c) => c.charCodeAt(0)));
  var sigma16 = _utf8ToBytes("expand 16-byte k");
  var sigma32 = _utf8ToBytes("expand 32-byte k");
  var sigma16_32 = u32(sigma16);
  var sigma32_32 = u32(sigma32);
  function rotl(a, b) {
    return a << b | a >>> 32 - b;
  }
  function isAligned322(b) {
    return b.byteOffset % 4 === 0;
  }
  var BLOCK_LEN = 64;
  var BLOCK_LEN32 = 16;
  var MAX_COUNTER = 2 ** 32 - 1;
  var U32_EMPTY = new Uint32Array();
  function runCipher(core, sigma, key, nonce, data, output, counter, rounds) {
    const len = data.length;
    const block = new Uint8Array(BLOCK_LEN);
    const b32 = u32(block);
    const isAligned = isAligned322(data) && isAligned322(output);
    const d32 = isAligned ? u32(data) : U32_EMPTY;
    const o32 = isAligned ? u32(output) : U32_EMPTY;
    for (let pos = 0; pos < len; counter++) {
      core(sigma, key, nonce, b32, counter, rounds);
      if (counter >= MAX_COUNTER)
        throw new Error("arx: counter overflow");
      const take = Math.min(BLOCK_LEN, len - pos);
      if (isAligned && take === BLOCK_LEN) {
        const pos32 = pos / 4;
        if (pos % 4 !== 0)
          throw new Error("arx: invalid block position");
        for (let j = 0, posj; j < BLOCK_LEN32; j++) {
          posj = pos32 + j;
          o32[posj] = d32[posj] ^ b32[j];
        }
        pos += BLOCK_LEN;
        continue;
      }
      for (let j = 0, posj; j < take; j++) {
        posj = pos + j;
        output[posj] = data[posj] ^ block[j];
      }
      pos += take;
    }
  }
  function createCipher(core, opts) {
    const { allowShortKeys, extendNonceFn, counterLength, counterRight, rounds } = checkOpts({ allowShortKeys: false, counterLength: 8, counterRight: false, rounds: 20 }, opts);
    if (typeof core !== "function")
      throw new Error("core must be a function");
    anumber(counterLength);
    anumber(rounds);
    abool(counterRight);
    abool(allowShortKeys);
    return (key, nonce, data, output, counter = 0) => {
      abytes(key);
      abytes(nonce);
      abytes(data);
      const len = data.length;
      if (output === void 0)
        output = new Uint8Array(len);
      abytes(output);
      anumber(counter);
      if (counter < 0 || counter >= MAX_COUNTER)
        throw new Error("arx: counter overflow");
      if (output.length < len)
        throw new Error(`arx: output (${output.length}) is shorter than data (${len})`);
      const toClean = [];
      let l = key.length;
      let k;
      let sigma;
      if (l === 32) {
        toClean.push(k = copyBytes(key));
        sigma = sigma32_32;
      } else if (l === 16 && allowShortKeys) {
        k = new Uint8Array(32);
        k.set(key);
        k.set(key, 16);
        sigma = sigma16_32;
        toClean.push(k);
      } else {
        throw new Error(`arx: invalid 32-byte key, got length=${l}`);
      }
      if (!isAligned322(nonce))
        toClean.push(nonce = copyBytes(nonce));
      const k32 = u32(k);
      if (extendNonceFn) {
        if (nonce.length !== 24)
          throw new Error(`arx: extended nonce must be 24 bytes`);
        extendNonceFn(sigma, k32, u32(nonce.subarray(0, 16)), k32);
        nonce = nonce.subarray(16);
      }
      const nonceNcLen = 16 - counterLength;
      if (nonceNcLen !== nonce.length)
        throw new Error(`arx: nonce must be ${nonceNcLen} or 16 bytes`);
      if (nonceNcLen !== 12) {
        const nc = new Uint8Array(12);
        nc.set(nonce, counterRight ? 0 : 12 - nonce.length);
        nonce = nc;
        toClean.push(nonce);
      }
      const n32 = u32(nonce);
      runCipher(core, sigma, k32, n32, data, output, counter, rounds);
      clean(...toClean);
      return output;
    };
  }

  // ../../esm/_poly1305.js
  var u8to16 = (a, i) => a[i++] & 255 | (a[i++] & 255) << 8;
  var Poly1305 = class {
    constructor(key) {
      this.blockLen = 16;
      this.outputLen = 16;
      this.buffer = new Uint8Array(16);
      this.r = new Uint16Array(10);
      this.h = new Uint16Array(10);
      this.pad = new Uint16Array(8);
      this.pos = 0;
      this.finished = false;
      key = toBytes(key);
      abytes(key, 32);
      const t0 = u8to16(key, 0);
      const t1 = u8to16(key, 2);
      const t2 = u8to16(key, 4);
      const t3 = u8to16(key, 6);
      const t4 = u8to16(key, 8);
      const t5 = u8to16(key, 10);
      const t6 = u8to16(key, 12);
      const t7 = u8to16(key, 14);
      this.r[0] = t0 & 8191;
      this.r[1] = (t0 >>> 13 | t1 << 3) & 8191;
      this.r[2] = (t1 >>> 10 | t2 << 6) & 7939;
      this.r[3] = (t2 >>> 7 | t3 << 9) & 8191;
      this.r[4] = (t3 >>> 4 | t4 << 12) & 255;
      this.r[5] = t4 >>> 1 & 8190;
      this.r[6] = (t4 >>> 14 | t5 << 2) & 8191;
      this.r[7] = (t5 >>> 11 | t6 << 5) & 8065;
      this.r[8] = (t6 >>> 8 | t7 << 8) & 8191;
      this.r[9] = t7 >>> 5 & 127;
      for (let i = 0; i < 8; i++)
        this.pad[i] = u8to16(key, 16 + 2 * i);
    }
    process(data, offset, isLast = false) {
      const hibit = isLast ? 0 : 1 << 11;
      const { h, r } = this;
      const r0 = r[0];
      const r1 = r[1];
      const r2 = r[2];
      const r3 = r[3];
      const r4 = r[4];
      const r5 = r[5];
      const r6 = r[6];
      const r7 = r[7];
      const r8 = r[8];
      const r9 = r[9];
      const t0 = u8to16(data, offset + 0);
      const t1 = u8to16(data, offset + 2);
      const t2 = u8to16(data, offset + 4);
      const t3 = u8to16(data, offset + 6);
      const t4 = u8to16(data, offset + 8);
      const t5 = u8to16(data, offset + 10);
      const t6 = u8to16(data, offset + 12);
      const t7 = u8to16(data, offset + 14);
      let h0 = h[0] + (t0 & 8191);
      let h1 = h[1] + ((t0 >>> 13 | t1 << 3) & 8191);
      let h2 = h[2] + ((t1 >>> 10 | t2 << 6) & 8191);
      let h3 = h[3] + ((t2 >>> 7 | t3 << 9) & 8191);
      let h4 = h[4] + ((t3 >>> 4 | t4 << 12) & 8191);
      let h5 = h[5] + (t4 >>> 1 & 8191);
      let h6 = h[6] + ((t4 >>> 14 | t5 << 2) & 8191);
      let h7 = h[7] + ((t5 >>> 11 | t6 << 5) & 8191);
      let h8 = h[8] + ((t6 >>> 8 | t7 << 8) & 8191);
      let h9 = h[9] + (t7 >>> 5 | hibit);
      let c = 0;
      let d0 = c + h0 * r0 + h1 * (5 * r9) + h2 * (5 * r8) + h3 * (5 * r7) + h4 * (5 * r6);
      c = d0 >>> 13;
      d0 &= 8191;
      d0 += h5 * (5 * r5) + h6 * (5 * r4) + h7 * (5 * r3) + h8 * (5 * r2) + h9 * (5 * r1);
      c += d0 >>> 13;
      d0 &= 8191;
      let d1 = c + h0 * r1 + h1 * r0 + h2 * (5 * r9) + h3 * (5 * r8) + h4 * (5 * r7);
      c = d1 >>> 13;
      d1 &= 8191;
      d1 += h5 * (5 * r6) + h6 * (5 * r5) + h7 * (5 * r4) + h8 * (5 * r3) + h9 * (5 * r2);
      c += d1 >>> 13;
      d1 &= 8191;
      let d2 = c + h0 * r2 + h1 * r1 + h2 * r0 + h3 * (5 * r9) + h4 * (5 * r8);
      c = d2 >>> 13;
      d2 &= 8191;
      d2 += h5 * (5 * r7) + h6 * (5 * r6) + h7 * (5 * r5) + h8 * (5 * r4) + h9 * (5 * r3);
      c += d2 >>> 13;
      d2 &= 8191;
      let d3 = c + h0 * r3 + h1 * r2 + h2 * r1 + h3 * r0 + h4 * (5 * r9);
      c = d3 >>> 13;
      d3 &= 8191;
      d3 += h5 * (5 * r8) + h6 * (5 * r7) + h7 * (5 * r6) + h8 * (5 * r5) + h9 * (5 * r4);
      c += d3 >>> 13;
      d3 &= 8191;
      let d4 = c + h0 * r4 + h1 * r3 + h2 * r2 + h3 * r1 + h4 * r0;
      c = d4 >>> 13;
      d4 &= 8191;
      d4 += h5 * (5 * r9) + h6 * (5 * r8) + h7 * (5 * r7) + h8 * (5 * r6) + h9 * (5 * r5);
      c += d4 >>> 13;
      d4 &= 8191;
      let d5 = c + h0 * r5 + h1 * r4 + h2 * r3 + h3 * r2 + h4 * r1;
      c = d5 >>> 13;
      d5 &= 8191;
      d5 += h5 * r0 + h6 * (5 * r9) + h7 * (5 * r8) + h8 * (5 * r7) + h9 * (5 * r6);
      c += d5 >>> 13;
      d5 &= 8191;
      let d6 = c + h0 * r6 + h1 * r5 + h2 * r4 + h3 * r3 + h4 * r2;
      c = d6 >>> 13;
      d6 &= 8191;
      d6 += h5 * r1 + h6 * r0 + h7 * (5 * r9) + h8 * (5 * r8) + h9 * (5 * r7);
      c += d6 >>> 13;
      d6 &= 8191;
      let d7 = c + h0 * r7 + h1 * r6 + h2 * r5 + h3 * r4 + h4 * r3;
      c = d7 >>> 13;
      d7 &= 8191;
      d7 += h5 * r2 + h6 * r1 + h7 * r0 + h8 * (5 * r9) + h9 * (5 * r8);
      c += d7 >>> 13;
      d7 &= 8191;
      let d8 = c + h0 * r8 + h1 * r7 + h2 * r6 + h3 * r5 + h4 * r4;
      c = d8 >>> 13;
      d8 &= 8191;
      d8 += h5 * r3 + h6 * r2 + h7 * r1 + h8 * r0 + h9 * (5 * r9);
      c += d8 >>> 13;
      d8 &= 8191;
      let d9 = c + h0 * r9 + h1 * r8 + h2 * r7 + h3 * r6 + h4 * r5;
      c = d9 >>> 13;
      d9 &= 8191;
      d9 += h5 * r4 + h6 * r3 + h7 * r2 + h8 * r1 + h9 * r0;
      c += d9 >>> 13;
      d9 &= 8191;
      c = (c << 2) + c | 0;
      c = c + d0 | 0;
      d0 = c & 8191;
      c = c >>> 13;
      d1 += c;
      h[0] = d0;
      h[1] = d1;
      h[2] = d2;
      h[3] = d3;
      h[4] = d4;
      h[5] = d5;
      h[6] = d6;
      h[7] = d7;
      h[8] = d8;
      h[9] = d9;
    }
    finalize() {
      const { h, pad } = this;
      const g = new Uint16Array(10);
      let c = h[1] >>> 13;
      h[1] &= 8191;
      for (let i = 2; i < 10; i++) {
        h[i] += c;
        c = h[i] >>> 13;
        h[i] &= 8191;
      }
      h[0] += c * 5;
      c = h[0] >>> 13;
      h[0] &= 8191;
      h[1] += c;
      c = h[1] >>> 13;
      h[1] &= 8191;
      h[2] += c;
      g[0] = h[0] + 5;
      c = g[0] >>> 13;
      g[0] &= 8191;
      for (let i = 1; i < 10; i++) {
        g[i] = h[i] + c;
        c = g[i] >>> 13;
        g[i] &= 8191;
      }
      g[9] -= 1 << 13;
      let mask = (c ^ 1) - 1;
      for (let i = 0; i < 10; i++)
        g[i] &= mask;
      mask = ~mask;
      for (let i = 0; i < 10; i++)
        h[i] = h[i] & mask | g[i];
      h[0] = (h[0] | h[1] << 13) & 65535;
      h[1] = (h[1] >>> 3 | h[2] << 10) & 65535;
      h[2] = (h[2] >>> 6 | h[3] << 7) & 65535;
      h[3] = (h[3] >>> 9 | h[4] << 4) & 65535;
      h[4] = (h[4] >>> 12 | h[5] << 1 | h[6] << 14) & 65535;
      h[5] = (h[6] >>> 2 | h[7] << 11) & 65535;
      h[6] = (h[7] >>> 5 | h[8] << 8) & 65535;
      h[7] = (h[8] >>> 8 | h[9] << 5) & 65535;
      let f = h[0] + pad[0];
      h[0] = f & 65535;
      for (let i = 1; i < 8; i++) {
        f = (h[i] + pad[i] | 0) + (f >>> 16) | 0;
        h[i] = f & 65535;
      }
      clean(g);
    }
    update(data) {
      aexists(this);
      data = toBytes(data);
      abytes(data);
      const { buffer, blockLen } = this;
      const len = data.length;
      for (let pos = 0; pos < len; ) {
        const take = Math.min(blockLen - this.pos, len - pos);
        if (take === blockLen) {
          for (; blockLen <= len - pos; pos += blockLen)
            this.process(data, pos);
          continue;
        }
        buffer.set(data.subarray(pos, pos + take), this.pos);
        this.pos += take;
        pos += take;
        if (this.pos === blockLen) {
          this.process(buffer, 0, false);
          this.pos = 0;
        }
      }
      return this;
    }
    destroy() {
      clean(this.h, this.r, this.buffer, this.pad);
    }
    digestInto(out) {
      aexists(this);
      aoutput(out, this);
      this.finished = true;
      const { buffer, h } = this;
      let { pos } = this;
      if (pos) {
        buffer[pos++] = 1;
        for (; pos < 16; pos++)
          buffer[pos] = 0;
        this.process(buffer, 0, true);
      }
      this.finalize();
      let opos = 0;
      for (let i = 0; i < 8; i++) {
        out[opos++] = h[i] >>> 0;
        out[opos++] = h[i] >>> 8;
      }
      return out;
    }
    digest() {
      const { buffer, outputLen } = this;
      this.digestInto(buffer);
      const res = buffer.slice(0, outputLen);
      this.destroy();
      return res;
    }
  };
  function wrapConstructorWithKey(hashCons) {
    const hashC = (msg, key) => hashCons(key).update(toBytes(msg)).digest();
    const tmp = hashCons(new Uint8Array(32));
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (key) => hashCons(key);
    return hashC;
  }
  var poly1305 = wrapConstructorWithKey((key) => new Poly1305(key));

  // ../../esm/chacha.js
  function chachaCore(s, k, n, out, cnt, rounds = 20) {
    let y00 = s[0], y01 = s[1], y02 = s[2], y03 = s[3], y04 = k[0], y05 = k[1], y06 = k[2], y07 = k[3], y08 = k[4], y09 = k[5], y10 = k[6], y11 = k[7], y12 = cnt, y13 = n[0], y14 = n[1], y15 = n[2];
    let x00 = y00, x01 = y01, x02 = y02, x03 = y03, x04 = y04, x05 = y05, x06 = y06, x07 = y07, x08 = y08, x09 = y09, x10 = y10, x11 = y11, x12 = y12, x13 = y13, x14 = y14, x15 = y15;
    for (let r = 0; r < rounds; r += 2) {
      x00 = x00 + x04 | 0;
      x12 = rotl(x12 ^ x00, 16);
      x08 = x08 + x12 | 0;
      x04 = rotl(x04 ^ x08, 12);
      x00 = x00 + x04 | 0;
      x12 = rotl(x12 ^ x00, 8);
      x08 = x08 + x12 | 0;
      x04 = rotl(x04 ^ x08, 7);
      x01 = x01 + x05 | 0;
      x13 = rotl(x13 ^ x01, 16);
      x09 = x09 + x13 | 0;
      x05 = rotl(x05 ^ x09, 12);
      x01 = x01 + x05 | 0;
      x13 = rotl(x13 ^ x01, 8);
      x09 = x09 + x13 | 0;
      x05 = rotl(x05 ^ x09, 7);
      x02 = x02 + x06 | 0;
      x14 = rotl(x14 ^ x02, 16);
      x10 = x10 + x14 | 0;
      x06 = rotl(x06 ^ x10, 12);
      x02 = x02 + x06 | 0;
      x14 = rotl(x14 ^ x02, 8);
      x10 = x10 + x14 | 0;
      x06 = rotl(x06 ^ x10, 7);
      x03 = x03 + x07 | 0;
      x15 = rotl(x15 ^ x03, 16);
      x11 = x11 + x15 | 0;
      x07 = rotl(x07 ^ x11, 12);
      x03 = x03 + x07 | 0;
      x15 = rotl(x15 ^ x03, 8);
      x11 = x11 + x15 | 0;
      x07 = rotl(x07 ^ x11, 7);
      x00 = x00 + x05 | 0;
      x15 = rotl(x15 ^ x00, 16);
      x10 = x10 + x15 | 0;
      x05 = rotl(x05 ^ x10, 12);
      x00 = x00 + x05 | 0;
      x15 = rotl(x15 ^ x00, 8);
      x10 = x10 + x15 | 0;
      x05 = rotl(x05 ^ x10, 7);
      x01 = x01 + x06 | 0;
      x12 = rotl(x12 ^ x01, 16);
      x11 = x11 + x12 | 0;
      x06 = rotl(x06 ^ x11, 12);
      x01 = x01 + x06 | 0;
      x12 = rotl(x12 ^ x01, 8);
      x11 = x11 + x12 | 0;
      x06 = rotl(x06 ^ x11, 7);
      x02 = x02 + x07 | 0;
      x13 = rotl(x13 ^ x02, 16);
      x08 = x08 + x13 | 0;
      x07 = rotl(x07 ^ x08, 12);
      x02 = x02 + x07 | 0;
      x13 = rotl(x13 ^ x02, 8);
      x08 = x08 + x13 | 0;
      x07 = rotl(x07 ^ x08, 7);
      x03 = x03 + x04 | 0;
      x14 = rotl(x14 ^ x03, 16);
      x09 = x09 + x14 | 0;
      x04 = rotl(x04 ^ x09, 12);
      x03 = x03 + x04 | 0;
      x14 = rotl(x14 ^ x03, 8);
      x09 = x09 + x14 | 0;
      x04 = rotl(x04 ^ x09, 7);
    }
    let oi = 0;
    out[oi++] = y00 + x00 | 0;
    out[oi++] = y01 + x01 | 0;
    out[oi++] = y02 + x02 | 0;
    out[oi++] = y03 + x03 | 0;
    out[oi++] = y04 + x04 | 0;
    out[oi++] = y05 + x05 | 0;
    out[oi++] = y06 + x06 | 0;
    out[oi++] = y07 + x07 | 0;
    out[oi++] = y08 + x08 | 0;
    out[oi++] = y09 + x09 | 0;
    out[oi++] = y10 + x10 | 0;
    out[oi++] = y11 + x11 | 0;
    out[oi++] = y12 + x12 | 0;
    out[oi++] = y13 + x13 | 0;
    out[oi++] = y14 + x14 | 0;
    out[oi++] = y15 + x15 | 0;
  }
  function hchacha(s, k, i, o32) {
    let x00 = s[0], x01 = s[1], x02 = s[2], x03 = s[3], x04 = k[0], x05 = k[1], x06 = k[2], x07 = k[3], x08 = k[4], x09 = k[5], x10 = k[6], x11 = k[7], x12 = i[0], x13 = i[1], x14 = i[2], x15 = i[3];
    for (let r = 0; r < 20; r += 2) {
      x00 = x00 + x04 | 0;
      x12 = rotl(x12 ^ x00, 16);
      x08 = x08 + x12 | 0;
      x04 = rotl(x04 ^ x08, 12);
      x00 = x00 + x04 | 0;
      x12 = rotl(x12 ^ x00, 8);
      x08 = x08 + x12 | 0;
      x04 = rotl(x04 ^ x08, 7);
      x01 = x01 + x05 | 0;
      x13 = rotl(x13 ^ x01, 16);
      x09 = x09 + x13 | 0;
      x05 = rotl(x05 ^ x09, 12);
      x01 = x01 + x05 | 0;
      x13 = rotl(x13 ^ x01, 8);
      x09 = x09 + x13 | 0;
      x05 = rotl(x05 ^ x09, 7);
      x02 = x02 + x06 | 0;
      x14 = rotl(x14 ^ x02, 16);
      x10 = x10 + x14 | 0;
      x06 = rotl(x06 ^ x10, 12);
      x02 = x02 + x06 | 0;
      x14 = rotl(x14 ^ x02, 8);
      x10 = x10 + x14 | 0;
      x06 = rotl(x06 ^ x10, 7);
      x03 = x03 + x07 | 0;
      x15 = rotl(x15 ^ x03, 16);
      x11 = x11 + x15 | 0;
      x07 = rotl(x07 ^ x11, 12);
      x03 = x03 + x07 | 0;
      x15 = rotl(x15 ^ x03, 8);
      x11 = x11 + x15 | 0;
      x07 = rotl(x07 ^ x11, 7);
      x00 = x00 + x05 | 0;
      x15 = rotl(x15 ^ x00, 16);
      x10 = x10 + x15 | 0;
      x05 = rotl(x05 ^ x10, 12);
      x00 = x00 + x05 | 0;
      x15 = rotl(x15 ^ x00, 8);
      x10 = x10 + x15 | 0;
      x05 = rotl(x05 ^ x10, 7);
      x01 = x01 + x06 | 0;
      x12 = rotl(x12 ^ x01, 16);
      x11 = x11 + x12 | 0;
      x06 = rotl(x06 ^ x11, 12);
      x01 = x01 + x06 | 0;
      x12 = rotl(x12 ^ x01, 8);
      x11 = x11 + x12 | 0;
      x06 = rotl(x06 ^ x11, 7);
      x02 = x02 + x07 | 0;
      x13 = rotl(x13 ^ x02, 16);
      x08 = x08 + x13 | 0;
      x07 = rotl(x07 ^ x08, 12);
      x02 = x02 + x07 | 0;
      x13 = rotl(x13 ^ x02, 8);
      x08 = x08 + x13 | 0;
      x07 = rotl(x07 ^ x08, 7);
      x03 = x03 + x04 | 0;
      x14 = rotl(x14 ^ x03, 16);
      x09 = x09 + x14 | 0;
      x04 = rotl(x04 ^ x09, 12);
      x03 = x03 + x04 | 0;
      x14 = rotl(x14 ^ x03, 8);
      x09 = x09 + x14 | 0;
      x04 = rotl(x04 ^ x09, 7);
    }
    let oi = 0;
    o32[oi++] = x00;
    o32[oi++] = x01;
    o32[oi++] = x02;
    o32[oi++] = x03;
    o32[oi++] = x12;
    o32[oi++] = x13;
    o32[oi++] = x14;
    o32[oi++] = x15;
  }

  var xchacha20 = /* @__PURE__ */ createCipher(chachaCore, {
    counterRight: false,
    counterLength: 8,
    extendNonceFn: hchacha,
    allowShortKeys: false
  });

  var ZEROS16 = /* @__PURE__ */ new Uint8Array(16);
  var updatePadded = (h, msg) => {
    h.update(msg);
    const left = msg.length % 16;
    if (left)
      h.update(ZEROS16.subarray(left));
  };
  var ZEROS32 = /* @__PURE__ */ new Uint8Array(32);
  function computeTag(fn, key, nonce, data, AAD) {
    const authKey = fn(key, nonce, ZEROS32);
    const h = poly1305.create(authKey);
    if (AAD)
      updatePadded(h, AAD);
    updatePadded(h, data);
    const num = u64Lengths(data.length, AAD ? AAD.length : 0, true);
    h.update(num);
    const res = h.digest();
    clean(authKey, num);
    return res;
  }
  var _poly1305_aead = (xorStream) => (key, nonce, AAD) => {
    const tagLength = 16;
    return {
      encrypt(plaintext, output) {
        const plength = plaintext.length;
        output = getOutput(plength + tagLength, output, false);
        output.set(plaintext);
        const oPlain = output.subarray(0, -tagLength);
        xorStream(key, nonce, oPlain, oPlain, 1);
        const tag = computeTag(xorStream, key, nonce, oPlain, AAD);
        output.set(tag, plength);
        clean(tag);
        return output;
      },
      decrypt(ciphertext, output) {
        output = getOutput(ciphertext.length - tagLength, output, false);
        const data = ciphertext.subarray(0, -tagLength);
        const passedTag = ciphertext.subarray(-tagLength);
        const tag = computeTag(xorStream, key, nonce, data, AAD);
        if (!equalBytes(passedTag, tag))
          throw new Error("invalid tag");
        output.set(ciphertext.subarray(0, -tagLength));
        xorStream(key, nonce, output, output, 1);
        clean(tag);
        return output;
      }
    };
  };
  var xchacha20poly1305 = /* @__PURE__ */ wrapCipher({ blockSize: 64, nonceLength: 24, tagLength: 16 }, _poly1305_aead(xchacha20));
  return {xchacha20poly1305}
})();

// checks if every value in an array is 0
function isBlank(arr) {
    return arr.every((element)=>element === 0)
}

async function getKeyFromBytes(bytes, canExport = false) {
    return await crypto.subtle.importKey("raw", bytes, "AES-GCM", canExport, ["encrypt", "decrypt"])
}

async function getKeyForDeriving(text, canExport = false) {
    let bytes = new TextEncoder().encode(text);
    return await crypto.subtle.importKey("raw", bytes, "PBKDF2", canExport, ["deriveKey"])
}

function getRandArray(length) {
    let rand = new Uint8Array(length);
    crypto.getRandomValues(rand);
    if (isBlank(rand)) {
        throw new Error("Failed to generate random values (just try again)");
    }
    return rand;
}

const DAP = {name: "AES-GCM", length: 256}

// sum the values inside the array
function getRandomInt(places) {
    return getRandArray(places).reduce((a,b)=>a+b)
}

async function getKey(key, derive, iters, salt) {
    if (derive) {
        salt = salt ?? getRandArray(129 + getRandomInt(2))
        iters = iters ?? 1_000_000 + getRandomInt(65500 * (10/(getRandomInt(1)+10)))
        let params = {name: "PBKDF2", hash: "SHA-512", salt: salt, iterations: iters}
        let cryptKey = await crypto.subtle.deriveKey(params, await getKeyForDeriving(key), DAP, false, ["encrypt", "decrypt"])
        return {key: cryptKey, derive, salt, iters}
    } else {
        let cryptKey = await getKeyFromBytes(new TextEncoder().encode(key));
        return {key: cryptKey, derive}
    }
}

async function encryptAes256Gcm(inputData, key) {
    let iv = getRandArray(12)
    const gcmParams = {name: "AES-GCM", iv: iv}
    let ciphertext = await crypto.subtle.encrypt(gcmParams, key, inputData)
    return { iv, ciphertext }
}

async function decryptAes256Gcm(ciphertext, key, iv) {
    const gcmParams = {name: "AES-GCM", iv: iv}
    let decrypted = await crypto.subtle.decrypt(gcmParams, key, ciphertext)
    return decrypted;
}

async function getEncryptedAes(inputData, pass, shouldDerive) {
    let { key, derive, salt, iters } = await getKey(pass, shouldDerive);
    let { iv, ciphertext } = await encryptAes256Gcm(inputData, key)
    let jsonData = { derive, salt, iters, iv };
    let strJson = JSON.stringify(jsonData);
    let encodedJson = new TextEncoder().encode(strJson)
    let encodedCiphertext = new Uint8Array(ciphertext);
    return {ciphertext: encodedCiphertext, params: encodedJson};
}

function objToUint8(obj) {
    return new Uint8Array(Object.values(obj))
}

async function decryptAes(ciphertext, pass, encodedParams) {
    let strjson = new TextDecoder().decode(encodedParams);
    let { derive, salt, iters, iv } = JSON.parse(strjson);
    if (iv) iv = objToUint8(iv);
    if (salt) salt = objToUint8(salt);
    let keyData = await getKey(pass, derive, iters, salt);
    let decrypted = await decryptAes256Gcm(ciphertext, keyData.key, iv)
    return decrypted;
}

const { xchacha20poly1305 } = nobleCiphers;

async function getKeyXCH(pass, derive, iters, salt) {
    if (derive) {
        salt = salt ?? getRandArray(129 + getRandomInt(2))
        iters = iters ?? 1_000_000 + getRandomInt(65500 * (10/(getRandomInt(1)+10)))
        let params = {name: "PBKDF2", hash: "SHA-512", salt: salt, iterations: iters}
        let cryptKey = await crypto.subtle.deriveKey(params, await getKeyForDeriving(pass, true), DAP, true, ["encrypt", "decrypt"])
        return {key: cryptKey, derive, salt, iters}
    } else {
        let cryptKey = await getKeyFromBytes(new TextEncoder().encode(pass), true);
        return {key: cryptKey, derive}
    }
}

function parseEncodedJson(arr) {
    let str = new TextDecoder.decode(arr);
    return JSON.parse(str);
}

async function getEncryptedXCH(inputData, pass, shouldDerive) {
    let nonce = getRandArray(24);
    let { key, derive, salt, iters } = await getKeyXCH(pass, shouldDerive)
    let keyBytes = new Uint8Array(await crypto.subtle.exportKey("raw", key))
    const chacha = xchacha20poly1305(keyBytes, nonce);
    const ciphertext = chacha.encrypt(inputData);
    let jsonData = { derive, salt, iters, nonce }
    let strJson = JSON.stringify(jsonData);
    let encodedJson = new TextEncoder().encode(strJson);
    return { ciphertext: ciphertext, params: encodedJson }
}

async function decryptXCH(ciphertext, pass, encodedParams) {
    let strjson = new TextDecoder().decode(encodedParams);
    let { derive, salt, iters, nonce } = JSON.parse(strjson);
    if (salt) salt = objToUint8(salt);
    nonce = objToUint8(nonce);
    let { key } = await getKeyXCH(pass, derive, iters, salt);
    let keyBytes = new Uint8Array(await crypto.subtle.exportKey("raw", key))
    const chacha = xchacha20poly1305(keyBytes, nonce)
    let decrypted = chacha.decrypt(ciphertext);
    return decrypted;
}

async function encryptDual(inputData, pass, shouldDerive) {
    showStep("Encryption step 1")
    let aes = await getEncryptedAes(inputData, pass, shouldDerive)
    let aesData = aes.ciphertext;
    let aesParams = aes.params;

    showStep("Encryption step 2")
    let xchForData = await getEncryptedXCH(aesData, pass, shouldDerive);
    showStep("Encryption step 3")
    let xchForParams = await getEncryptedXCH(aesParams, pass, shouldDerive);

    return {
        dataData: xchForData.ciphertext,
        dataParams: xchForData.params,
        paramsData: xchForParams.ciphertext,
        paramsParams: xchForParams.params
    }
}

async function decryptDual(dataData, dataParams, paramsData, paramsParams, pass) {
    showStep("Decryption step 1");
    let aesData = await decryptXCH(dataData, pass, dataParams);
    showStep("Decryption step 2")
    let aesParams = await decryptXCH(paramsData, pass, paramsParams);

    showStep("Decryption step 3")
    let finalDecrypted = await decryptAes(aesData, pass, aesParams);
    return finalDecrypted;
}
    </script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const form = document.getElementById('secureForm');
            const fileInput = document.getElementById('fileInput');
            fileInput.value = ''
            const fileDropZone = document.getElementById('fileDropZone');
            const fileInfo = document.getElementById('fileInfo');
            const fileName = document.getElementById('fileName');
            const fileSize = document.getElementById('fileSize');
            const resultContainer = document.getElementById('resultContainer');
            const resultTitle = document.getElementById('resultTitle');
            const resultContent = document.getElementById('resultContent');
            const loading = document.getElementById('loading');
            const loadingSteps = document.getElementById('loadingSteps');
            const stepInfo = document.getElementById('stepinfo');
            const encryptBtn = document.getElementById('encryptBtn');
            const decryptBtn = document.getElementById('decryptBtn');

            document.getElementById('downloadBtn').addEventListener('click', function() {
                if (resultFileBlob) {
                    const url = window.URL.createObjectURL(resultFileBlob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = resultInfo.fileName;
                    document.body.appendChild(a);
                    a.click();
                    window.URL.revokeObjectURL(url);
                    document.body.removeChild(a);
                }
            });

            // Handle file selection
            fileInput.addEventListener('change', function(e) {
                if (this.files && this.files[0]) {
                    handleFile(this.files[0]);
                }
            });

            // Handle drag and drop
            fileDropZone.addEventListener('dragover', function(e) {
                e.preventDefault();
                this.classList.add('drag-over');
            });

            fileDropZone.addEventListener('dragleave', function() {
                this.classList.remove('drag-over');
            });

            fileDropZone.addEventListener('drop', function(e) {
                e.preventDefault();
                this.classList.remove('drag-over');

                if (e.dataTransfer.files && e.dataTransfer.files[0]) {
                    fileInput.files = e.dataTransfer.files;
                    handleFile(e.dataTransfer.files[0]);
                }
            });

            // Click to select file
            fileDropZone.addEventListener('click', function() {
                fileInput.click();
            });

            function handleFile(file) {
                // Display file info
                fileName.textContent = file.name;
                fileSize.textContent = formatFileSize(file.size);
                fileInfo.classList.add('show');
            }

            function formatFileSize(bytes) {
                if (bytes === 0) return '0 Bytes';
                const k = 1024;
                const sizes = ['Bytes', 'KB', 'MB', 'GB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
            }

            // Show result function
            function showResult(title, content, isError = false) {
                resultTitle.textContent = title;
                resultContent.innerHTML = content;
                resultContainer.className = 'result-container';
                if (isError) {
                    resultContainer.classList.add('error');
                } else {
                    resultContainer.classList.add('success');
                }
                resultContainer.classList.add('show');
            }

            // Show loading
            function showLoading() {
                loading.classList.add('show');
            }

            // Hide loading
            function hideLoading() {
                loading.classList.remove('show');
                stepInfo.classList.remove('active');
            }

            // Show step
            function showStep(info) {
                stepInfo.classList.add('active')
                stepInfo.innerText = info;
            }
            window.showStep = showStep;

            // Handle form submission
            encryptBtn.addEventListener('click', async function() {
                await processFileSubmission(true, false);
            });

            decryptBtn.addEventListener('click', async function() {
                await processFileSubmission(false, false);
            });

            let resultFileBlob = null;
            let resultInfo;

            async function processFileSubmission(encrypt) {
                const password = document.getElementById('password').value;
                const shouldDerive = document.getElementById('deriveKey').checked;
                const encryptFilename = document.getElementById('encryptFilename').checked;
                const burnAfterRead = document.getElementById('burnAfterRead').checked;
                document.getElementById('downloadBtn').style.display = 'none';
                if (!shouldDerive && password.length != 32) {
                    showResult('Error', 'Since you are not deriving the key, you must input a password exactly 32 characters long', true)
                    return;
                }
                if (password.length == 0) {
                    showResult('Error', 'Password is required',true)
                    return;
                }
                const file = fileInput.files[0];

                if (!file) {
                    showResult('Error', 'Please select a file', true);
                    return;
                }

                try {
                    // Show loading
                    showLoading();
                    resultContainer.classList.remove('show');

                    // Read file as ArrayBuffer
                    const arrayBuffer = await file.arrayBuffer();
                    const uint8Array = new Uint8Array(arrayBuffer);

                    await processFileData(uint8Array, password, shouldDerive, encrypt, encryptFilename, file.name);

                } catch (error) {
                    console.error('Error processing file:', error);
                    showResult('Error', `Error processing file: ${error.message}`, true);
                } finally {
                    hideLoading();
                }
            }

            function createBlobFromArrays(arrays) {
                // Store array sizes in a header
                const sizes = new Uint32Array(arrays.map(arr => arr.length));
                const sizesBuffer = new Uint8Array(sizes.buffer); // or JSON.stringify(sizes)

                // Concatenate all arrays
                const combined = new Uint8Array(sizesBuffer.length + arrays.reduce((acc, arr) => acc + arr.length, 0));

                let offset = 0;
                // Copy sizes
                combined.set(sizesBuffer, offset);
                offset += sizesBuffer.length;

                // Copy arrays
                arrays.forEach(arr => {
                    combined.set(arr, offset);
                    offset += arr.length;
                });

                return new Blob([combined], { type: 'application/octet-stream' });
            }

            async function parseBlobToArrays(uint8Array) {
                // Assuming first 16 bytes contain 8 32-bit integers (sizes)
                const sizes = new Uint32Array(uint8Array.buffer, 0, 8);

                const arrays = [];
                let offset = sizes.length * 4; // Skip the header

                for (let i = 0; i < 8; i++) {
                    const array = uint8Array.slice(offset, offset + sizes[i]);
                    arrays.push(array);
                    offset += sizes[i];
                }

                return arrays;
            }

            async function processFileData(fileData, password, shouldDerive, encrypt, encryptFilename, fileName) {
                let enc;
                resultInfo = {
                    encrypt: encrypt,
                    fileName: null
                }
                if (encrypt) {
                    enc = await encryptDual(fileData, password, shouldDerive);
                    if (encryptFilename) {
                        let fn = await encryptDual(new TextEncoder().encode(fileName), password, shouldDerive);
                        enc.fndataData = fn.dataData;
                        enc.fndataParams = fn.dataParams;
                        enc.fnparamsData = fn.paramsData
                        enc.fnparamsParams = fn.paramsParams;
                    }
                } else {
                    let arrs = await parseBlobToArrays(fileData);
                    try {
                        enc = await decryptDual(arrs[0], arrs[1], arrs[2], arrs[3], password, shouldDerive);
                        if (arrs[4].length > 0) {
                            let fn = await decryptDual(arrs[4], arrs[5], arrs[6], arrs[7], password, shouldDerive);
                            resultInfo.fileName = new TextDecoder().decode(fn);
                        } else {
                            resultInfo.fileName = fileName.replace(/\.enc$/, '');
                        }
                    } catch (e) {
                        e.message =  e.message + ". This error was most likely caused by an invalid password or trying to decrypt an unencrypted file"
                        throw e;
                    }
                }


                if (encrypt) {
                    let arrtoenc = [enc.dataData, enc.dataParams, enc.paramsData, enc.paramsParams, new Uint8Array(), new Uint8Array(), new Uint8Array(), new Uint8Array()]
                    if (encryptFilename) {
                        resultInfo.fileName = 'encrypted-file.enc'
                        arrtoenc = [enc.dataData, enc.dataParams, enc.paramsData, enc.paramsParams, enc.fndataData, enc.fndataParams, enc.fnparamsData, enc.fnparamsParams]
                    } else {
                        resultInfo.fileName = fileName + '.enc'
                    }
                    resultFileBlob = createBlobFromArrays(arrtoenc)
                } else {
                    resultFileBlob = new Blob([enc], { type: 'application/octet-stream' });
                }
                const resultMessage = `
                    <p><strong>File processed successfully!</strong></p>
                    <p><strong>Original name:</strong> ${fileName}</p>
                    <p><strong>New name:</strong> ${resultInfo.fileName}</p>
                    <p><strong>Input size:</strong> ${fileSize.textContent}</p>
                    <p><strong>Output size:</strong> ${formatFileSize(resultFileBlob.size)}</p>
                    <p><strong>Key derivation:</strong> ${shouldDerive ? 'Enabled' : 'Disabled'}</p>
                    <p><strong>Operation:</strong> ${encrypt ? 'Encryption' : 'Decryption'}</p>
                `;

                showResult('Success', resultMessage);

                document.getElementById('downloadBtn').style.display = 'block';
            }
        });
    </script>
</body>
</html>
